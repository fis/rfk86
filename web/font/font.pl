#! /usr/bin/env perl

use strict;
use warnings;

use GD;
use XML::Writer;

# Set settings.

my ($cw, $ch) = (4, 6);

my $ppp = 96; # points per pixel

# Output the boilerplate SVG code.

my $svgdoc = '';
my $svg = new XML::Writer(OUTPUT => \$svgdoc);

$svg->xmlDecl('UTF-8', 'yes');

$svg->startTag('svg',
               'width' => '128px', 'height' => '64px',
               'version' => '1.1',
               'xmlns' => 'http://www.w3.org/2000/svg');

$svg->startTag('defs');

$svg->startTag('font',
               'id' => 'rfk86',
               'horiz-adv-x' => '384');

$svg->startTag('font-face',
               'font-family' => 'Rfk-Regular',
               'font-style' => 'normal',
               'font-weight' => 'normal',
               'units-per-em' => '576',
               'cap-height' => '480', 'x-height' => '384',
               'ascent' => '480', 'descent' => '96');

$svg->endTag('font-face');

# Slurp in glyphs and output glyph elements.

foreach my $file (sort glob "font*.png")
{
    next unless $file =~ /^font([0-9a-f]{4})\.png$/;
    my $block = $1;

    my $png = GD::Image->newFromPng($file) or die "can't read: $file";
    my ($w, $h) = $png->getBounds;
    $w % $cw == 0 or die "$file: bad width: not divisible by $cw";
    $h % $ch == 0 or die "$file: bad height: not divisible by $ch";

    my $codepoint = hex($block);

    for (my $y = 0; $y < $h; $y += $ch)
    {
        for (my $x = 0; $x < $w; $x += $cw)
        {
            if ($codepoint < 32 or ($codepoint >= 127 and $codepoint < 160))
            {
                $codepoint++;
                next;
            }

            my @bitmap;
            $#bitmap = $ch-1;

            for (my $cy = 0; $cy < $ch; $cy++)
            {
                my @row;
                $#row = $cw-1;

                for (my $cx = 0; $cx < $cw; $cx++)
                {
                    my ($r, $g, $b) = $png->rgb($png->getPixel($x+$cx, $y+$cy));
                    $row[$cx] = ($r+$g+$b > 382 ? 0 : 1);
                }

                $bitmap[$cy] = \@row;
            }

            my $path = bitmap2path(\@bitmap);

            my %args = ('unicode' => sprintf('#x%04x;', $codepoint));
            $args{'d'} = $path if $path;
            $args{'d'} ||= "M0,0";

            $svg->emptyTag('glyph', %args);
            $codepoint++;
        }
    }
}

# Trailing parts of the SVG container file.

$svg->endTag('font');
$svg->endTag('defs');

$svg->dataElement('text', "Hello, world!",
                  'x' => '16', 'y' => '32',
                  'font-family' => "'Rfk-Regular'",
                  'font-size' => '12');

$svg->endTag('svg');

$svg->end;

$svgdoc =~ s/unicode="#x/unicode="&#x/g;

open OUT, '>:utf8', 'font.svg' or die "can't write font.svg: $!";
print OUT $svgdoc;
close OUT;

# Bitmap to polygon conversion code.

sub bitmap2path
{
    my $bmp = shift;

    # Find all border segments in the bitmap.

    my @borders;

    foreach my $y (0 .. $ch-1)
    {
        foreach my $x (0 .. $cw-1)
        {
            my $p = $bmp->[$y]->[$x];

            # (x, y) -> (x, y-1) edges (y=0 row only)
            push @borders, [$x, $y, $x+1, $y] if $y == 0 and $p;
            # (x, y) -> (x-1, y) edges (x=0 row only)
            push @borders, [$x, $y, $x, $y+1] if $x == 0 and $p;
            # (x, y) -> (x, y+1) edges
            push @borders, [$x, $y+1, $x+1, $y+1]
                if $p != ($y == $ch-1 ? 0 : $bmp->[$y+1]->[$x]);
            # (x, y) -> (x+1, y) edges
            push @borders, [$x+1, $y, $x+1, $y+1]
                if $p != ($x == $cw-1 ? 0 : $bmp->[$y]->[$x+1]);
        }
    }

    # Find all the pixel-border cycles generated by the segments.

    my @polys;

    my %borders; # map of all links from "x,y"
    foreach my $y (0 .. $ch)
    {
        $borders{"$_,$y"} = {} foreach (0 .. $cw);
    }

    foreach my $b (@borders)
    {
        my $bp1 = "$b->[0],$b->[1]";
        my $bp2 = "$b->[2],$b->[3]";
        $borders{$bp1}->{$bp2} = $b;
        $borders{$bp2}->{$bp1} = $b;
    }

    foreach my $startb (@borders)
    {
        my $b = $startb;
        my $at = "$b->[0],$b->[1]";
        my $n = "$b->[2],$b->[3]";
        next unless $borders{$at}->{$n}; # already crawled

        my ($atx, $aty, $nx, $ny) = @$b;

        if (left_pixel($nx, $ny, $nx-$atx, $ny-$aty, $bmp))
        {
            ($nx, $ny, $atx, $aty) = @$b;
            ($n, $at) = ($at, $n);
        }

        my $start = $at;
        my @poly = ([$atx, $aty]);

        while (1)
        {
            push @poly, [$nx, $ny] if $n ne $start;
            delete $borders{$at}->{$n};
            delete $borders{$n}->{$at};
            last if $n eq $start;

            $at = $n;
            ($nx, $ny) = follow($b, $at, $borders{$at}, $bmp);
            $n = "$nx,$ny";
            $b = $borders{$at}->{$n};
        }

        push @polys, \@poly;
    }

    # Remove redundant polygon control points, map to coords.

    foreach my $poly (@polys)
    {
        my @corners;

        for (my $i = 0; $i <= $#$poly; $i++)
        {
            my $prev = ($i > 0 ? $poly->[$i-1] : $poly->[$#$poly]);
            my $at = $poly->[$i];
            my $next = ($i < $#$poly ? $poly->[$i+1] : $poly->[0]);

            next if $at->[0] - $prev->[0] == $next->[0] - $at->[0]
                and $at->[1] - $prev->[1] == $next->[1] - $at->[1];

            push @corners, [coord(@$at)];
        }

        @$poly = @corners;
    }

    # Find and fix self-intersecting points.

    my %corners;

    foreach my $poly (@polys)
    {
        foreach my $i (0 .. $#$poly)
        {
            my $p = join(',', @{$poly->[$i]});
            $corners{$p} ||= [];
            push @{$corners{$p}}, $poly;
        }
    }

    foreach my $corner (keys %corners)
    {
        my ($x, $y) = map { int } split /,/, $corner;
        my $polys = $corners{$corner};
        next unless scalar @$polys > 1;
        die "More than two intersecting polygons" if scalar @$polys > 2;

        # Find the corner-point in the first poly.

        my $i = 0;
        my $p = $polys->[0];
        my $at;

        while ($i <= $#$p)
        {
            $at = $p->[$i];
            last if $at->[0] == $x and $at->[1] == $y;
            $i++;
        }

        die "Can't find intersection" if $i > $#$p;

        # Add a small notch to the first polygon.

        my $prev = ($i > 0 ? $p->[$i-1] : $p->[$#$p]);
        my $next = ($i < $#$p ? $p->[$i+1] : $p->[0]);

        my $pdx = sgn($prev->[0] - $at->[0]);
        my $pdy = sgn($prev->[1] - $at->[1]);
        my $ndx = sgn($next->[0] - $at->[0]);
        my $ndy = sgn($next->[1] - $at->[1]);

        my @notch;
        push @notch, [$at->[0] + $pdx, $at->[1] + $pdy];
        push @notch, [$at->[0] + $pdx+$ndx, $at->[1] + $pdy+$ndy];
        push @notch, [$at->[0] + $ndx, $at->[1] + $ndy];

        splice @$p, $i, 1, @notch;

        # Fixup other corner-references to this poly.
    }

    # Generate a path for the corner points.

    my @path;

    foreach my $poly (@polys)
    {
        my ($px, $py) = @{$poly->[0]};

        my $path = "M$px,$py";
        foreach my $i (1 .. $#$poly)
        {
            my ($nx, $ny) = @{$poly->[$i]};
            if ($px == $nx)
            {
                $path .= "V$ny";
            }
            elsif ($py == $ny)
            {
                $path .= "H$nx";
            }
            else
            {
                $path .= "L$nx,$ny";
            }
            ($px, $py) = ($nx, $ny);
        }
        $path .= 'z';

        push @path, $path;
    }

    return join(' ', @path);
}

sub follow
{
    my ($b, $at, $choices, $bmp) = @_;

    my ($atx, $aty, $prevx, $prevy) = @$b;

    ($atx, $aty, $prevx, $prevy) = ($b->[2], $b->[3], $b->[0], $b->[1])
        if "$atx,$aty" ne $at;

    # Try to circle around the pixel as closely as possible.

    my $dx = $atx - $prevx;
    my $dy = $aty - $prevy;

    foreach my $turn (1, 0, -1)
    {
        my ($nextx, $nexty) = turn($atx, $aty, $dx, $dy, $turn);
        return ($nextx, $nexty) if $choices->{"$nextx,$nexty"};
    }

    die "sorry, I got confused"; # should not happen
}

sub turn
{
    my ($x, $y, $dx, $dy, $turn) = @_;

    return ($x+$dx, $y+$dy) unless $turn;

    ($dx, $dy) = ($dy*(-$turn), $dx*$turn);

    return ($x+$dx, $y+$dy);
}

sub left_pixel
{
    my ($x, $y, $dx, $dy, $bmp) = @_;

    my $leftx = $x;
    $leftx-- if $dx == 1 or $dy == -1;

    my $lefty = $y;
    $lefty-- if $dx == 1 or $dy == 1;

    my $left = 0;
    $left = 1
        if $leftx >= 0 and $leftx < $cw
        and $lefty >= 0 and $lefty < $ch
        and $bmp->[$lefty]->[$leftx];

    return $left;
}

sub coord
{
    my ($x, $y) = @_;
    return ($x * $ppp, ($cw-$y+1) * $ppp);
}

sub sgn
{
    my $i = shift;
    return 0 unless $i;
    return $i < 0 ? -1 : 1;
}
